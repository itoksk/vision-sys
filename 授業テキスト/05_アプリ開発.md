# ç¬¬8-9æ™‚ï¼šå‚·æ¤œå‡ºAIã‚¢ãƒ—ãƒªã‚’é–‹ç™ºã—ã‚ˆã†

## ğŸ¯ ä»Šæ—¥ã®ç›®æ¨™
è¦ä»¶å®šç¾©æ›¸ã‚’åŸºã«ã€å®Ÿéš›ã«å‹•ãå‚·æ¤œå‡ºAIã‚¢ãƒ—ãƒªã‚’å®Œæˆã•ã›ã‚‹ï¼

---

## ğŸ“ é–‹ç™ºã®æº–å‚™

### å¿…è¦ãªã‚‚ã®ç¢ºèª

- [ ] Google Colabã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹
- [ ] Teachable Machineã§ä½œã£ãŸãƒ¢ãƒ‡ãƒ«ï¼ˆkeras_model.h5ã€labels.txtï¼‰
- [ ] è¦ä»¶å®šç¾©æ›¸
- [ ] ãƒ†ã‚¹ãƒˆç”¨ã®ç”»åƒ

### é–‹ç™ºã®æµã‚Œ

```mermaid
graph LR
    A[ç’°å¢ƒæº–å‚™] --> B[ãƒ¢ãƒ‡ãƒ«èª­è¾¼]
    B --> C[åŸºæœ¬æ©Ÿèƒ½å®Ÿè£…]
    C --> D[UIä½œæˆ]
    D --> E[ãƒ†ã‚¹ãƒˆ]
    E --> F[æ”¹å–„]
```

---

## ğŸš€ ã‚¹ãƒ†ãƒƒãƒ—1ï¼šGoogle Colabã®æº–å‚™

### æ–°ã—ã„ãƒãƒ¼ãƒˆãƒ–ãƒƒã‚¯ã‚’ä½œæˆ

1. **Google Colabã‚’é–‹ã**
   - https://colab.research.google.com/
   - ã€Œãƒ•ã‚¡ã‚¤ãƒ«ã€â†’ã€Œæ–°ã—ã„ãƒãƒ¼ãƒˆãƒ–ãƒƒã‚¯ã€

2. **åå‰ã‚’å¤‰æ›´**
   - `å‚·æ¤œå‡ºAIã‚¢ãƒ—ãƒª_ãƒãƒ¼ãƒ å.ipynb`

3. **GitHubã«ä¿å­˜è¨­å®š**
   - ã€Œãƒ•ã‚¡ã‚¤ãƒ«ã€â†’ã€ŒGitHub ã«ã‚³ãƒ”ãƒ¼ã‚’ä¿å­˜ã€
   - ãƒªãƒã‚¸ãƒˆãƒªã‚’é¸æŠ

### å¿…è¦ãªãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«

```python
# ã‚»ãƒ«1ï¼šãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
print("ğŸ“¦ å¿…è¦ãªãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¦ã„ã¾ã™...")

!pip install tensorflow gradio opencv-python pillow numpy pandas matplotlib
!pip install -q gradio --upgrade

print("âœ… ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«å®Œäº†ï¼")
```

å®Ÿè¡Œæ–¹æ³•ï¼š`Shift + Enter`

---

## ğŸ“‚ ã‚¹ãƒ†ãƒƒãƒ—2ï¼šãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®æ§‹é€ ã‚’ä½œã‚‹

### Google Driveã¨é€£æº

```python
# ã‚»ãƒ«2ï¼šGoogle Driveã®ãƒã‚¦ãƒ³ãƒˆ
from google.colab import drive
drive.mount('/content/drive')

# ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚©ãƒ«ãƒ€ã®ä½œæˆ
import os
project_name = "damage_detection_project"  # ã‚ãªãŸã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåã«å¤‰æ›´
project_path = f'/content/drive/MyDrive/{project_name}'

# ãƒ•ã‚©ãƒ«ãƒ€æ§‹é€ ã‚’ä½œæˆ
folders = ['models', 'test_images', 'results', 'logs']
for folder in folders:
    os.makedirs(f'{project_path}/{folder}', exist_ok=True)
    
print(f"âœ… ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚©ãƒ«ãƒ€ã‚’ä½œæˆã—ã¾ã—ãŸ: {project_path}")
print("ğŸ“ ãƒ•ã‚©ãƒ«ãƒ€æ§‹é€ :")
for folder in folders:
    print(f"  â””â”€â”€ {folder}/")
```

### ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰

```python
# ã‚»ãƒ«3ï¼šãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
from google.colab import files

print("ğŸ“¤ Teachable Machineã§ä½œæˆã—ãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„")
print("å¿…è¦ãªãƒ•ã‚¡ã‚¤ãƒ«:")
print("  1. keras_model.h5")
print("  2. labels.txt")

uploaded = files.upload()

# ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚’modelsãƒ•ã‚©ãƒ«ãƒ€ã«ç§»å‹•
import shutil
for filename in uploaded.keys():
    shutil.move(filename, f"{project_path}/models/{filename}")
    print(f"âœ… {filename} ã‚’ä¿å­˜ã—ã¾ã—ãŸ")
```

---

## ğŸ¤– ã‚¹ãƒ†ãƒƒãƒ—3ï¼šAIãƒ¢ãƒ‡ãƒ«ã®å®Ÿè£…

### åŸºæœ¬çš„ãªæ¤œå‡ºå™¨ã‚¯ãƒ©ã‚¹

```python
# ã‚»ãƒ«4ï¼šæ¤œå‡ºå™¨ã‚¯ãƒ©ã‚¹ã®å®šç¾©
import tensorflow as tf
import numpy as np
from PIL import Image
from datetime import datetime
import json

class DamageDetector:
    """å‚·æ¤œå‡ºAIã‚¯ãƒ©ã‚¹"""
    
    def __init__(self, model_path, labels_path):
        """åˆæœŸåŒ–"""
        print("ğŸ¤– AIãƒ¢ãƒ‡ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ã„ã¾ã™...")
        
        # ãƒ¢ãƒ‡ãƒ«ã¨ãƒ©ãƒ™ãƒ«ã®èª­ã¿è¾¼ã¿
        self.model = tf.keras.models.load_model(model_path, compile=False)
        
        # ãƒ©ãƒ™ãƒ«ã®èª­ã¿è¾¼ã¿
        with open(labels_path, 'r', encoding='utf-8') as f:
            self.labels = [line.strip() for line in f.readlines()]
        
        # æ¤œæŸ»å±¥æ­´ã‚’ä¿å­˜ã™ã‚‹ãƒªã‚¹ãƒˆ
        self.history = []
        
        print("âœ… ãƒ¢ãƒ‡ãƒ«ã®æº–å‚™å®Œäº†ï¼")
        print(f"èªè­˜å¯èƒ½ãªã‚¯ãƒ©ã‚¹: {self.labels}")
    
    def predict(self, image):
        """ç”»åƒã‹ã‚‰å‚·ã‚’æ¤œå‡º"""
        # ç”»åƒã®å‰å‡¦ç†
        if isinstance(image, str):
            # ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã®å ´åˆ
            img = Image.open(image).convert('RGB')
        else:
            # numpyé…åˆ—ã®å ´åˆ
            img = Image.fromarray(image).convert('RGB')
        
        # ã‚µã‚¤ã‚ºã‚’224x224ã«å¤‰æ›´ï¼ˆTeachable Machineã®è¦æ±‚ã‚µã‚¤ã‚ºï¼‰
        img = img.resize((224, 224))
        
        # numpyé…åˆ—ã«å¤‰æ›ã—ã¦æ­£è¦åŒ–
        img_array = np.array(img) / 255.0
        img_array = np.expand_dims(img_array, axis=0)
        
        # äºˆæ¸¬å®Ÿè¡Œ
        predictions = self.model.predict(img_array, verbose=0)
        
        # çµæœã‚’è¾æ›¸å½¢å¼ã§è¿”ã™
        results = {}
        for i, label in enumerate(self.labels):
            # "0 è‰¯å“" â†’ "è‰¯å“" ã®ã‚ˆã†ã«ç•ªå·ã‚’é™¤å»
            clean_label = label.split(' ', 1)[1] if ' ' in label else label
            results[clean_label] = float(predictions[0][i])
        
        # å±¥æ­´ã«è¿½åŠ 
        self.history.append({
            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'results': results
        })
        
        return results

# æ¤œå‡ºå™¨ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆ
detector = DamageDetector(
    model_path=f"{project_path}/models/keras_model.h5",
    labels_path=f"{project_path}/models/labels.txt"
)
```

### ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ

```python
# ã‚»ãƒ«5ï¼šå‹•ä½œãƒ†ã‚¹ãƒˆ
# ãƒ†ã‚¹ãƒˆç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
print("ğŸ–¼ï¸ ãƒ†ã‚¹ãƒˆç”¨ã®ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„")
test_upload = files.upload()

# æœ€åˆã®ç”»åƒã§ãƒ†ã‚¹ãƒˆ
test_image = list(test_upload.keys())[0]
results = detector.predict(test_image)

print("\nğŸ“Š æ¤œå‡ºçµæœ:")
for label, probability in results.items():
    print(f"  {label}: {probability:.1%}")
    
# æœ€ã‚‚ç¢ºç‡ã®é«˜ã„ã‚¯ãƒ©ã‚¹ã‚’è¡¨ç¤º
max_label = max(results, key=results.get)
print(f"\nğŸ¯ åˆ¤å®š: {max_label}")
```

---

## ğŸ¨ ã‚¹ãƒ†ãƒƒãƒ—4ï¼šGradioã§ä½¿ã„ã‚„ã™ã„UIã‚’ä½œã‚‹

### ã‚·ãƒ³ãƒ—ãƒ«ãªUIç‰ˆ

```python
# ã‚»ãƒ«6ï¼šã‚·ãƒ³ãƒ—ãƒ«ãªGradio UI
import gradio as gr

def simple_detect(image):
    """ã‚·ãƒ³ãƒ—ãƒ«ãªæ¤œå‡ºé–¢æ•°"""
    if image is None:
        return "ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„"
    
    # æ¤œå‡ºå®Ÿè¡Œ
    results = detector.predict(image)
    
    # çµæœã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ä½œæˆ
    max_label = max(results, key=results.get)
    confidence = results[max_label]
    
    if max_label == "ä¸è‰¯å“" or max_label == "bad":
        emoji = "âŒ"
        message = "ä¸è‰¯å“ãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸ"
    else:
        emoji = "âœ…"
        message = "è‰¯å“ã§ã™"
    
    output = f"{emoji} åˆ¤å®š: {max_label}\n"
    output += f"ç¢ºä¿¡åº¦: {confidence:.1%}\n\n"
    output += "è©³ç´°:\n"
    for label, prob in results.items():
        output += f"  {label}: {prob:.1%}\n"
    
    return output

# Gradioã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã®ä½œæˆ
simple_app = gr.Interface(
    fn=simple_detect,
    inputs=gr.Image(label="æ¤œæŸ»ç”»åƒ", type="numpy"),
    outputs=gr.Textbox(label="åˆ¤å®šçµæœ", lines=5),
    title="ğŸ” å‚·æ¤œå‡ºAIã‚·ã‚¹ãƒ†ãƒ ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ç‰ˆï¼‰",
    description="éƒ¨å“ã®ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã¨ã€AIãŒå‚·ã®æœ‰ç„¡ã‚’åˆ¤å®šã—ã¾ã™ã€‚"
)

# ã‚¢ãƒ—ãƒªã‚’èµ·å‹•
simple_app.launch(share=True)
```

### é«˜æ©Ÿèƒ½ç‰ˆUI

```python
# ã‚»ãƒ«7ï¼šé«˜æ©Ÿèƒ½ãªGradio UI
import pandas as pd

# ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã¨ã—ã¦å±¥æ­´ã‚’ä¿å­˜
inspection_history = []

def advanced_detect(image):
    """é«˜åº¦ãªæ¤œå‡ºé–¢æ•°"""
    if image is None:
        return None, "ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„", None, None
    
    # æ¤œå‡ºå®Ÿè¡Œ
    results = detector.predict(image)
    
    # åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯
    bad_prob = results.get('ä¸è‰¯å“', results.get('bad', 0))
    good_prob = results.get('è‰¯å“', results.get('good', 0))
    
    # åˆ¤å®šåŸºæº–ï¼ˆè¦ä»¶å®šç¾©æ›¸ã«åŸºã¥ãï¼‰
    if bad_prob > 0.8:
        status = "ä¸è‰¯å“"
        action = "å»ƒæ£„ã¾ãŸã¯å†åŠ å·¥ã‚’æ¨å¥¨"
        emoji = "âŒ"
        confidence = "é«˜"
    elif bad_prob > 0.5:
        status = "è¦ç¢ºèª"
        action = "ç›®è¦–ã§ã®å†ç¢ºèªã‚’æ¨å¥¨"
        emoji = "âš ï¸"
        confidence = "ä¸­"
    else:
        status = "è‰¯å“"
        action = "æ¬¡å·¥ç¨‹ã¸é€²ã‚ã¦å•é¡Œã‚ã‚Šã¾ã›ã‚“"
        emoji = "âœ…"
        confidence = "é«˜"
    
    # ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ä½œæˆ
    message = f"""
### {emoji} åˆ¤å®šçµæœ: {status}

**ä¿¡é ¼åº¦**: {confidence}
**æ¨å¥¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³**: {action}

**è©³ç´°ç¢ºç‡**:
- è‰¯å“: {good_prob:.1%}
- ä¸è‰¯å“: {bad_prob:.1%}
"""
    
    # å±¥æ­´ã«è¿½åŠ 
    inspection_history.append({
        'æ¤œæŸ»æ—¥æ™‚': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
        'åˆ¤å®š': status,
        'ä¿¡é ¼åº¦': confidence,
        'ä¸è‰¯å“ç¢ºç‡': f"{bad_prob:.1%}"
    })
    
    # å±¥æ­´ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ¬ãƒ¼ãƒ ï¼ˆæœ€æ–°10ä»¶ï¼‰
    history_df = pd.DataFrame(inspection_history[-10:])
    
    # çµ±è¨ˆæƒ…å ±
    if len(inspection_history) > 0:
        total = len(inspection_history)
        good_count = sum(1 for h in inspection_history if h['åˆ¤å®š'] == 'è‰¯å“')
        bad_count = sum(1 for h in inspection_history if h['åˆ¤å®š'] == 'ä¸è‰¯å“')
        check_count = sum(1 for h in inspection_history if h['åˆ¤å®š'] == 'è¦ç¢ºèª')
        
        stats = f"""
### ğŸ“Š æ¤œæŸ»çµ±è¨ˆï¼ˆæœ¬æ—¥ï¼‰
- **ç·æ¤œæŸ»æ•°**: {total}ä»¶
- **è‰¯å“**: {good_count}ä»¶ ({good_count/total*100:.1f}%)
- **ä¸è‰¯å“**: {bad_count}ä»¶ ({bad_count/total*100:.1f}%)
- **è¦ç¢ºèª**: {check_count}ä»¶ ({check_count/total*100:.1f}%)
"""
    else:
        stats = "çµ±è¨ˆæƒ…å ±ã¯ã¾ã ã‚ã‚Šã¾ã›ã‚“"
    
    return results, message, history_df, stats

# é«˜æ©Ÿèƒ½UIã®ä½œæˆ
with gr.Blocks(title="å‚·æ¤œå‡ºAIã‚·ã‚¹ãƒ†ãƒ ", theme=gr.themes.Soft()) as advanced_app:
    gr.Markdown("""
    # ğŸ­ å‚·æ¤œå‡ºAIã‚·ã‚¹ãƒ†ãƒ 
    
    è£½é€ éƒ¨å“ã®å‚·ã‚’è‡ªå‹•ã§æ¤œå‡ºã—ã¾ã™ã€‚ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ã€Œæ¤œæŸ»é–‹å§‹ã€ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„ã€‚
    """)
    
    with gr.Tab("ğŸ” æ¤œæŸ»"):
        with gr.Row():
            with gr.Column(scale=1):
                input_image = gr.Image(
                    label="æ¤œæŸ»ç”»åƒ",
                    type="numpy",
                    height=300
                )
                inspect_btn = gr.Button(
                    "ğŸ” æ¤œæŸ»é–‹å§‹",
                    variant="primary",
                    size="lg"
                )
                
                # ä½¿ã„æ–¹
                with gr.Accordion("ğŸ“– ä½¿ã„æ–¹", open=False):
                    gr.Markdown("""
                    1. æ¤œæŸ»ã—ãŸã„éƒ¨å“ã®ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
                    2. ã€Œæ¤œæŸ»é–‹å§‹ã€ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯
                    3. AIãŒå‚·ã®æœ‰ç„¡ã‚’åˆ¤å®šã—ã¾ã™
                    
                    **æ’®å½±ã®ã‚³ãƒ„**:
                    - æ˜ã‚‹ã„å ´æ‰€ã§æ’®å½±
                    - éƒ¨å“å…¨ä½“ãŒå†™ã‚‹ã‚ˆã†ã«
                    - ãƒ”ãƒ³ãƒˆã‚’åˆã‚ã›ã‚‹
                    """)
            
            with gr.Column(scale=1):
                output_label = gr.Label(
                    label="åˆ¤å®šç¢ºç‡",
                    num_top_classes=2
                )
                output_message = gr.Markdown(
                    label="åˆ¤å®šçµæœ",
                    value="ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„"
                )
    
    with gr.Tab("ğŸ“Š çµ±è¨ˆ"):
        stats_display = gr.Markdown(label="çµ±è¨ˆæƒ…å ±")
        history_table = gr.Dataframe(
            label="æ¤œæŸ»å±¥æ­´ï¼ˆæœ€æ–°10ä»¶ï¼‰",
            headers=["æ¤œæŸ»æ—¥æ™‚", "åˆ¤å®š", "ä¿¡é ¼åº¦", "ä¸è‰¯å“ç¢ºç‡"]
        )
        
        export_btn = gr.Button("ğŸ“¥ å±¥æ­´ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰", variant="secondary")
        export_msg = gr.Textbox(label="ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰çŠ¶æ…‹", interactive=False)
    
    # ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼
    inspect_btn.click(
        fn=advanced_detect,
        inputs=input_image,
        outputs=[output_label, output_message, history_table, stats_display]
    )
    
    def export_history():
        if len(inspection_history) > 0:
            df = pd.DataFrame(inspection_history)
            filename = f"inspection_history_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
            df.to_csv(filename, index=False, encoding='utf-8-sig')
            return f"âœ… {filename} ã¨ã—ã¦ä¿å­˜ã—ã¾ã—ãŸ"
        return "âŒ ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹å±¥æ­´ãŒã‚ã‚Šã¾ã›ã‚“"
    
    export_btn.click(fn=export_history, outputs=export_msg)

# ã‚¢ãƒ—ãƒªã‚’èµ·å‹•
advanced_app.launch(share=True)
```

---

## ğŸ§ª ã‚¹ãƒ†ãƒƒãƒ—5ï¼šãƒ†ã‚¹ãƒˆã¨æ”¹å–„

### ãƒ†ã‚¹ãƒˆã‚·ãƒ¼ãƒˆä½œæˆ

```python
# ã‚»ãƒ«8ï¼šãƒ†ã‚¹ãƒˆå®Ÿè¡Œã¨è¨˜éŒ²
def run_tests(test_folder):
    """ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œã—ã¦çµæœã‚’è¨˜éŒ²"""
    test_results = []
    
    # ãƒ†ã‚¹ãƒˆãƒ•ã‚©ãƒ«ãƒ€å†…ã®ç”»åƒã‚’å–å¾—
    test_images = []
    for category in ['good', 'bad']:
        folder = f"{test_folder}/{category}"
        if os.path.exists(folder):
            for img in os.listdir(folder):
                if img.endswith(('.jpg', '.png', '.jpeg')):
                    test_images.append({
                        'path': f"{folder}/{img}",
                        'true_label': 'è‰¯å“' if category == 'good' else 'ä¸è‰¯å“',
                        'filename': img
                    })
    
    # å„ç”»åƒã§ãƒ†ã‚¹ãƒˆ
    for img_info in test_images:
        results = detector.predict(img_info['path'])
        
        # äºˆæ¸¬ãƒ©ãƒ™ãƒ«ã‚’æ±ºå®š
        bad_prob = results.get('ä¸è‰¯å“', results.get('bad', 0))
        if bad_prob > 0.5:
            pred_label = 'ä¸è‰¯å“'
        else:
            pred_label = 'è‰¯å“'
        
        # æ­£è§£ã‹ã©ã†ã‹
        correct = img_info['true_label'] == pred_label
        
        test_results.append({
            'ãƒ•ã‚¡ã‚¤ãƒ«å': img_info['filename'],
            'æ­£è§£': img_info['true_label'],
            'äºˆæ¸¬': pred_label,
            'ä¸è‰¯å“ç¢ºç‡': f"{bad_prob:.1%}",
            'åˆ¤å®š': 'â—‹' if correct else 'Ã—'
        })
    
    # ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ¬ãƒ¼ãƒ ã«å¤‰æ›
    results_df = pd.DataFrame(test_results)
    
    # ç²¾åº¦è¨ˆç®—
    accuracy = sum(1 for r in test_results if r['åˆ¤å®š'] == 'â—‹') / len(test_results)
    
    print(f"ğŸ“Š ãƒ†ã‚¹ãƒˆçµæœ")
    print(f"ãƒ†ã‚¹ãƒˆç”»åƒæ•°: {len(test_results)}æš")
    print(f"ç²¾åº¦: {accuracy:.1%}")
    print("\nè©³ç´°:")
    print(results_df)
    
    # CSVã«ä¿å­˜
    results_df.to_csv(f"{project_path}/results/test_results.csv", index=False, encoding='utf-8-sig')
    
    return results_df, accuracy

# ãƒ†ã‚¹ãƒˆç”»åƒãƒ•ã‚©ãƒ«ãƒ€ã‚’æŒ‡å®šã—ã¦å®Ÿè¡Œ
# test_results, accuracy = run_tests(f"{project_path}/test_images")
```

### ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¸¬å®š

```python
# ã‚»ãƒ«9ï¼šå‡¦ç†é€Ÿåº¦ã®æ¸¬å®š
import time

def measure_performance(image_path, n_trials=10):
    """å‡¦ç†é€Ÿåº¦ã‚’æ¸¬å®š"""
    times = []
    
    for i in range(n_trials):
        start_time = time.time()
        _ = detector.predict(image_path)
        end_time = time.time()
        
        process_time = end_time - start_time
        times.append(process_time)
    
    avg_time = np.mean(times)
    max_time = np.max(times)
    min_time = np.min(times)
    
    print(f"â±ï¸ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¸¬å®šçµæœï¼ˆ{n_trials}å›ã®å¹³å‡ï¼‰")
    print(f"å¹³å‡å‡¦ç†æ™‚é–“: {avg_time:.3f}ç§’")
    print(f"æœ€é€Ÿ: {min_time:.3f}ç§’")
    print(f"æœ€é…: {max_time:.3f}ç§’")
    
    # è¦ä»¶ï¼ˆ3ç§’ä»¥å†…ï¼‰ã‚’æº€ãŸã—ã¦ã„ã‚‹ã‹
    if avg_time <= 3.0:
        print("âœ… è¦ä»¶ã‚’æº€ãŸã—ã¦ã„ã¾ã™ï¼ˆ3ç§’ä»¥å†…ï¼‰")
    else:
        print("âŒ è¦ä»¶ã‚’æº€ãŸã—ã¦ã„ã¾ã›ã‚“ï¼ˆ3ç§’ã‚’è¶…éï¼‰")
    
    return times

# æ¸¬å®šå®Ÿè¡Œ
# times = measure_performance("test_image.jpg")
```

---

## ğŸ¯ ã‚¹ãƒ†ãƒƒãƒ—6ï¼šã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã¨æ‹¡å¼µ

### ã‚«ãƒ¡ãƒ©é€£æºæ©Ÿèƒ½ã®è¿½åŠ 

```python
# ã‚»ãƒ«10ï¼šã‚«ãƒ¡ãƒ©æ’®å½±æ©Ÿèƒ½ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
from IPython.display import display, Javascript
from google.colab.output import eval_js
from base64 import b64decode
import io

def take_photo(filename='photo.jpg', quality=0.8):
    """Webã‚«ãƒ¡ãƒ©ã§å†™çœŸã‚’æ’®å½±"""
    js = Javascript('''
    async function takePhoto(quality) {
      const div = document.createElement('div');
      const capture = document.createElement('button');
      capture.textContent = 'ğŸ“¸ æ’®å½±';
      capture.style.padding = '10px 20px';
      capture.style.fontSize = '16px';
      capture.style.backgroundColor = '#4CAF50';
      capture.style.color = 'white';
      capture.style.border = 'none';
      capture.style.borderRadius = '5px';
      capture.style.cursor = 'pointer';
      
      div.appendChild(capture);

      const video = document.createElement('video');
      video.style.display = 'block';
      video.style.width = '400px';
      video.style.margin = '10px 0';
      
      const stream = await navigator.mediaDevices.getUserMedia({video: true});

      document.body.appendChild(div);
      div.appendChild(video);
      video.srcObject = stream;
      await video.play();

      google.colab.output.setIframeHeight(document.documentElement.scrollHeight, true);

      await new Promise((resolve) => capture.onclick = resolve);

      const canvas = document.createElement('canvas');
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      canvas.getContext('2d').drawImage(video, 0, 0);
      stream.getVideoTracks()[0].stop();
      div.remove();
      return canvas.toDataURL('image/jpeg', quality);
    }
    ''')
    display(js)
    data = eval_js('takePhoto({})'.format(quality))
    binary = b64decode(data.split(',')[1])
    
    with open(filename, 'wb') as f:
        f.write(binary)
    
    return filename

# ã‚«ãƒ¡ãƒ©æ’®å½±ãƒ†ã‚¹ãƒˆ
# photo = take_photo()
# results = detector.predict(photo)
# print(f"æ’®å½±ã—ãŸç”»åƒã®åˆ¤å®šçµæœ: {results}")
```

### ãƒãƒƒãƒå‡¦ç†æ©Ÿèƒ½

```python
# ã‚»ãƒ«11ï¼šè¤‡æ•°ç”»åƒã®ä¸€æ‹¬å‡¦ç†
def batch_process(image_folder):
    """ãƒ•ã‚©ãƒ«ãƒ€å†…ã®ç”»åƒã‚’ä¸€æ‹¬å‡¦ç†"""
    results = []
    
    # ãƒ•ã‚©ãƒ«ãƒ€å†…ã®ç”»åƒã‚’å–å¾—
    images = [f for f in os.listdir(image_folder) 
              if f.endswith(('.jpg', '.png', '.jpeg'))]
    
    print(f"ğŸ”„ {len(images)}æšã®ç”»åƒã‚’å‡¦ç†ã—ã¾ã™...")
    
    for i, img_file in enumerate(images):
        img_path = os.path.join(image_folder, img_file)
        
        # æ¤œå‡ºå®Ÿè¡Œ
        detection_result = detector.predict(img_path)
        
        # åˆ¤å®š
        bad_prob = detection_result.get('ä¸è‰¯å“', detection_result.get('bad', 0))
        if bad_prob > 0.5:
            judgment = 'ä¸è‰¯å“'
        else:
            judgment = 'è‰¯å“'
        
        results.append({
            'ãƒ•ã‚¡ã‚¤ãƒ«å': img_file,
            'åˆ¤å®š': judgment,
            'ä¸è‰¯å“ç¢ºç‡': bad_prob,
            'å‡¦ç†æ—¥æ™‚': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        })
        
        # é€²æ—è¡¨ç¤º
        print(f"  [{i+1}/{len(images)}] {img_file} â†’ {judgment}")
    
    # çµæœã‚’DataFrameã«
    results_df = pd.DataFrame(results)
    
    # çµ±è¨ˆè¡¨ç¤º
    print("\nğŸ“Š ãƒãƒƒãƒå‡¦ç†çµæœ:")
    print(f"ç·æ•°: {len(results)}æš")
    print(f"è‰¯å“: {sum(1 for r in results if r['åˆ¤å®š'] == 'è‰¯å“')}æš")
    print(f"ä¸è‰¯å“: {sum(1 for r in results if r['åˆ¤å®š'] == 'ä¸è‰¯å“')}æš")
    
    return results_df

# ãƒãƒƒãƒå‡¦ç†å®Ÿè¡Œä¾‹
# batch_results = batch_process(f"{project_path}/test_images")
```

---

## ğŸ“± ã‚¹ãƒ†ãƒƒãƒ—7ï¼šã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³å¯¾å¿œ

### QRã‚³ãƒ¼ãƒ‰ã§ã‚¢ã‚¯ã‚»ã‚¹

```python
# ã‚»ãƒ«12ï¼šQRã‚³ãƒ¼ãƒ‰ç”Ÿæˆ
import qrcode
from IPython.display import Image as IPImage

def generate_qr_code(url):
    """URLã®QRã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆ"""
    qr = qrcode.QRCode(
        version=1,
        error_correction=qrcode.constants.ERROR_CORRECT_L,
        box_size=10,
        border=4,
    )
    qr.add_data(url)
    qr.make(fit=True)
    
    img = qr.make_image(fill_color="black", back_color="white")
    img.save("app_qr.png")
    
    print("ğŸ“± ã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³ã§ã‚¢ã‚¯ã‚»ã‚¹:")
    print("ä»¥ä¸‹ã®QRã‚³ãƒ¼ãƒ‰ã‚’èª­ã¿å–ã£ã¦ãã ã•ã„")
    display(IPImage("app_qr.png", width=200))

# Gradioã‚¢ãƒ—ãƒªèµ·å‹•æ™‚ã®public URLã‚’ä½¿ç”¨
# generate_qr_code("https://xxxxx.gradio.live")
```

---

## ğŸ‰ å®Œæˆã¨ã¾ã¨ã‚

### æˆæœç‰©ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

- [ ] **åŸºæœ¬æ©Ÿèƒ½ã®å®Ÿè£…**
  - [ ] ç”»åƒã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰æ©Ÿèƒ½
  - [ ] AIåˆ¤å®šæ©Ÿèƒ½
  - [ ] çµæœè¡¨ç¤ºæ©Ÿèƒ½

- [ ] **è¿½åŠ æ©Ÿèƒ½ã®å®Ÿè£…**
  - [ ] åˆ¤å®šå±¥æ­´ã®è¨˜éŒ²
  - [ ] çµ±è¨ˆæƒ…å ±ã®è¡¨ç¤º
  - [ ] CSVã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
  - [ ] ãƒãƒƒãƒå‡¦ç†ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰

- [ ] **å“è³ªè¦ä»¶ã®é”æˆ**
  - [ ] å‡¦ç†æ™‚é–“3ç§’ä»¥å†…
  - [ ] åˆ¤å®šç²¾åº¦90%ä»¥ä¸Š
  - [ ] ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

- [ ] **ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆä½œæˆ**
  - [ ] ä½¿ã„æ–¹ã®èª¬æ˜
  - [ ] ãƒ†ã‚¹ãƒˆçµæœã®è¨˜éŒ²
  - [ ] æ”¹å–„ç‚¹ã®ãƒ¡ãƒ¢

### ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ä¿å­˜

```python
# ã‚»ãƒ«13ï¼šãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ä¿å­˜
# å…¨ã¦ã®æˆæœç‰©ã‚’GitHubã«ãƒ—ãƒƒã‚·ãƒ¥
print("ğŸ’¾ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ä¿å­˜ã—ã¦ã„ã¾ã™...")

# 1. ã“ã®ãƒãƒ¼ãƒˆãƒ–ãƒƒã‚¯ã‚’ä¿å­˜
print("1. ãƒ•ã‚¡ã‚¤ãƒ« â†’ GitHub ã«ã‚³ãƒ”ãƒ¼ã‚’ä¿å­˜")

# 2. ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã®ç¢ºèª
print("2. models/ãƒ•ã‚©ãƒ«ãƒ€ã«ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚‹ã“ã¨ã‚’ç¢ºèª")

# 3. ãƒ†ã‚¹ãƒˆçµæœã®ç¢ºèª
print("3. results/ãƒ•ã‚©ãƒ«ãƒ€ã«ãƒ†ã‚¹ãƒˆçµæœãŒã‚ã‚‹ã“ã¨ã‚’ç¢ºèª")

# 4. ã‚¢ãƒ—ãƒªã®URLã‚’è¨˜éŒ²
app_info = {
    "app_name": "å‚·æ¤œå‡ºAIã‚·ã‚¹ãƒ†ãƒ ",
    "team": "ã‚ãªãŸã®ãƒãƒ¼ãƒ å",
    "created_date": datetime.now().strftime('%Y-%m-%d'),
    "model_accuracy": "è¨˜éŒ²ã—ãŸç²¾åº¦",
    "gradio_url": "ã‚¢ãƒ—ãƒªã®URL"
}

with open(f"{project_path}/app_info.json", 'w', encoding='utf-8') as f:
    json.dump(app_info, f, ensure_ascii=False, indent=2)

print("âœ… ä¿å­˜å®Œäº†ï¼")
```

---

## ğŸ¤” ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°

### ã‚ˆãã‚ã‚‹ã‚¨ãƒ©ãƒ¼ã¨å¯¾å‡¦æ³•

**ã‚¨ãƒ©ãƒ¼1: ãƒ¢ãƒ‡ãƒ«ãŒèª­ã¿è¾¼ã‚ãªã„**
```python
# ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’ç¢ºèª
print(os.listdir(f"{project_path}/models/"))
# keras_model.h5 ã¨ labels.txt ãŒã‚ã‚‹ã‹ç¢ºèª
```

**ã‚¨ãƒ©ãƒ¼2: GradioãŒèµ·å‹•ã—ãªã„**
```python
# Gradioã‚’å†ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
!pip install gradio --upgrade
# ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã‚’å†èµ·å‹•
```

**ã‚¨ãƒ©ãƒ¼3: ç”»åƒãŒèªè­˜ã•ã‚Œãªã„**
```python
# ç”»åƒå½¢å¼ã‚’ç¢ºèªï¼ˆJPG, PNGï¼‰
# ç”»åƒã‚µã‚¤ã‚ºã‚’ç¢ºèªï¼ˆå¤§ãã™ããªã„ã‹ï¼‰
```

### ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã®æ”¹å–„

1. **ç”»åƒã‚µã‚¤ã‚ºã®æœ€é©åŒ–**
   - ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰æ™‚ã«è‡ªå‹•ãƒªã‚µã‚¤ã‚º

2. **ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®æ´»ç”¨**
   - åŒã˜ç”»åƒã¯å†è¨ˆç®—ã—ãªã„

3. **ãƒãƒƒãƒå‡¦ç†ã®ä¸¦åˆ—åŒ–**
   - è¤‡æ•°ç”»åƒã‚’åŒæ™‚å‡¦ç†

---

## ğŸ æ¬¡å›äºˆå‘Šï¼šç™ºè¡¨æº–å‚™

### æº–å‚™ã™ã‚‹ã‚‚ã®
1. **ãƒ‡ãƒ¢å‹•ç”»**ï¼ˆ1-2åˆ†ï¼‰
2. **ãƒ—ãƒ¬ã‚¼ãƒ³è³‡æ–™**ï¼ˆ5æšç¨‹åº¦ï¼‰
3. **æ”¹å–„ææ¡ˆ**ï¼ˆ3ã¤ä»¥ä¸Šï¼‰

### ç™ºè¡¨ã§ä¼ãˆã‚‹ã“ã¨
- ä½œã£ãŸã‚¢ãƒ—ãƒªã®ç‰¹å¾´
- å·¥å¤«ã—ãŸç‚¹
- è‹¦åŠ´ã—ãŸç‚¹
- ä»Šå¾Œã®æ”¹å–„æ¡ˆ

**ãŠç–²ã‚Œã•ã¾ã§ã—ãŸï¼ç´ æ™´ã‚‰ã—ã„ã‚¢ãƒ—ãƒªãŒå®Œæˆã—ã¾ã—ãŸã­ï¼** ğŸŠ